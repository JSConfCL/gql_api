# Como Ejecutar el proyecto

- Asegurate de tener el archivo .dev.vars (P√≠dele al equipo los valores correspondientes.)
  - Puedes correr una BDD local si te parece.
  - Para correr el proyecto con las BDD de desarrollo, tienes que agregar un archivo `.dev.vars` con los valores de las mismas.
  - Preguntale al equipo por esto, o crea tu propia BDD en [turso.tech](https://turso.tech/) para obtener los valores
  - ```
    DATABASE_URL="XXXXXXXXXXXX"
    DATABASE_TOKEN="XXXXXX"
    ```
- Finalmente, `npm i` & `num run dev`

# C√≥mo contribuir al proyecto

- Si buscas una feature nueva, sugi√©rela creando un issue [ac√°](https://github.com/JSConfCL/gql_api/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc).
- Haz un fork del repositorio y crea una nueva rama para tu funcionalidad o correcci√≥n.
- Realiza tus cambios, y escribe pruebas que cubran el nuevo c√≥digo.
- Env√≠a una solicitud de pull.

# C√≥mo escribir tests

## Preparaci√≥n del entorno de prueba

Antes de empezar a escribir tus tests, aseg√∫rate de tener un entorno de prueba adecuado. Puedes necesitar borrar y recrear la base de datos antes de cada test para asegurarte de que los datos de un test no afecten a los dem√°s. En nuestros ejemplos, usamos la funci√≥n clearDatabase() en el hook afterEach() para lograr esto.

## Escribir la query o mutaci√≥n

(Ejemplos [en esta carpeta](https://github.com/JSConfCL/gql_api/blob/main/src/tests/user))
Define la query o mutation GraphQL que quieres que tu resolver maneje en un archivo `.gql`.
Por ejemplo

```graphql
query getUsers {
  users {
    id
    name
    email
  }
}
```

## Generar c√≥digo

Para poder correr los test, necesitamos tener funciones y variables en JavaScript/Typescript, no en "graphql".
Usaremos el archivo `.gql` que creamos recien, y correremos el comando `npm run generate`.
Esto generar√° codigo y tipos asociados a esta operaci√≥n de graphql, por ejemplo:

```typescript
/* eslint-disable */
/* @ts-nocheck */
/* prettier-ignore */
/* This file is automatically generated using `npm run graphql:types` */
import type * as Types from '../../generated/types';

import type { JsonObject } from "type-fest";
import gql from "graphql-tag";
export type GetUsersQueryVariables = Types.Exact<{ [key: string]: never }>;

export type GetUsersQuery = {
  __typename?: "Query";
  users: Array<{
    __typename?: "User";
    id: string;
    name: string | null;
    email: string | null;
  }>;
};

export const GetUsers = gql`
  query getUsers {
    users {
      id
      name
      email
    }
  }
`;
```

## Escribir el test

En nuestro caso, usamos vitest. Tu test debe ejecutar la consulta o mutaci√≥n usando, y luego verificar que la respuesta sea la esperada. Aqu√≠ hay un ejemplo:

```TS
describe("My Resolver Tests", () => {
  it("Should return the correct data", async () => {
    // Ac√° ir√° el codigo del test
  });
});
```

## Inserta data en tu BDD

Usa (o crea) m√©todos en [./src/tests/\_\_fixtures/index.ts](./src/tests/__fixtures/index.ts) para pre-popular tu BDD.

Por ejemplo:

```TS
import { insertUser } from "~/tests/__fixtures";
describe("My Resolver Tests", () => {
  it("Should return the correct data", async () => {
    const user = await insertUser();
    const user2 = await insertUser({ email: "email@especifico.com" });
  });
});
```

## Ejecuta tu query o mutaci√≥n.

Tenemos un helper para realizar esto, llamado `executeGraphqlOperation`, donde puedes pasar la operaci√≥n que definiste en el parametro `"document"`.
La query y tipos los debes traer desde tu archivo generado.

Por ejemplo:

> üö®üö® IMPORTANTE üö®üö®
> `executeGraphqlOperation` puede recibir gen√©ricos de typescript para hacer m√°s facil escribir tests, recuerda pasarlos.

```TS
import { insertUser, executeGraphqlOperation } from "~/tests/__fixtures";
import {
  GetUsers,
  GetUsersQuery,
  GetUsersQueryVariables,
} from "~/tests/user/getUsers.generated";

describe("My Resolver Tests", () => {
  it("Should return the correct data", async () => {
    const user = await insertUser();
    const user2 = await insertUser({ email: "email@especifico.com" });
    const response = await executeGraphqlOperation<
      GetUsersQuery,
      GetUsersQueryVariables,
    >({
      document: GetUsers,
    });
  });
});
```

## Verifica tus respuestas:

Puedes usar m√©todos assert o expect de [Vitest](https://vitest.dev/api/expect.html)

```TS
import { insertUser. executeGraphqlOperation } from "~/tests/__fixtures";
import {
  GetUsers,
  GetUsersQuery,
  GetUsersQueryVariables,
} from "~/tests/user/getUsers.generated";

describe("My Resolver Tests", () => {
  it("Should return the correct data", async () => {
    const user = await insertUser();
    const user2 = await insertUser({ email: "email@especifico.com" });
    const response = await executeGraphqlOperation<
      GetUsersQuery,
      GetUsersQueryVariables,
    >({
      document: GetUsers,
    });
    assert.equal(response.errors, undefined);
    assert.equal(response.data?.users.length, 2);
    assert.equal(response.data?.users[0].id, user.id);
    assert.equal(response.data?.users[1].id, user2.id);
  });
});

```

## Manejo de errores

Adem√°s de verificar que tu resolver devuelve los datos correctos, verifica c√≥mo maneja los errores. Por ejemplo, puedes escribir un test que pase datos incorrectos a tu mutaci√≥n y luego verificar que la respuesta contiene el error correcto, o que falla donde deber√≠a fallar üòÄ.

# Migraciones

Nuestra BDD es turso, usando `libsql` en local. Usamos `drizzle` y `drizzle-kit` para manejar conexiones a la BDD, que genera automaticamente archivos de migraciones cuando cambias tus modelos, lo que hace muchisimo m√°s facil es escribrlas.

## C√≥mo escribir migraciones?

### 1. Actualiza el esquema.

Primero, necesitas actualizar el archivo del esquema en `./src/datasources/db/schema.ts`.
Este archivo define la estructura de la base de datos.
Por ejemplo, aqu√≠ es donde se definen las tablas y sus campos, as√≠ como las relaciones entre las tablas.
Para definir una tabla, utilizas la funci√≥n `sqliteTable()`, donde el primer argumento es el nombre de la tabla y el segundo es un objeto que define los campos de la tabla.

Por ejemplo:

```TS
export const usersSchema = sqliteTable("users", {
  id: text("id").unique().notNull(),
  name: text("name"),
  bio: text("bio", { length: 1024 }),
  // ...
});
```

En este ejemplo, se define una tabla users con varios campos, incluyendo id, name, y bio. Los campos se definen utilizando funciones como text() e integer(), y se pueden agregar opciones adicionales, como unique(), notNull(), y default().

### 2. Genera los archivos de migraci√≥n.

Una vez que hayas actualizado el esquema, debes generar los archivos de migraci√≥n. Para hacerlo, ejecuta npx db:generate.

### 3. Verifica las migraciones:

Antes de ejecutar las migraciones, verifica que est√°n funcionando correctamente.
Puedes hacer esto corriendo todos los tests. Estos geeneran una BDD desde 0, y corren todas las migraciones antes de correr los tests.

### 4. Ejecuta las migraciones:

Finalmente, ejecuta las migraciones con `npm run db:migrate`.
Estos comandos utilizan las variables de entorno definidas en el archivo .dev.vars para conectarse a las BDD de desarrollo.

# Requisitos

- Tener un archivo `.dev.vars` con el siguiente contenido

```txt
DATABASE_URL="PREGUNTALE AL EQUIPO POR ESTO"
DATABASE_TOKEN="PREGUNTALE AL EQUIPO POR ESTO"
```

## Como correr tests

- `npm run test`

# STACK

- Turso:
  Una herramienta para generar c√≥digo TypeScript a partir de archivos de especificaci√≥n. Es √∫til para crear una API de tipo fuerte y garantizar la coherencia entre los diferentes componentes de un sistema.

- GraphQL Yoga:
  Un servidor GraphQL f√°cil de configurar que se apoya en Express.js. Proporciona una forma sencilla de crear servidores GraphQL que se pueden conectar a cualquier fuente de datos.

- Zod:
  Una biblioteca de validaci√≥n y an√°lisis de datos para JavaScript y TypeScript. Se utiliza para definir y validar esquemas de datos.

- Drizzle:
  ORM (Object-Relational Mapping) para SQLite en TypeScript. Ayuda a interactuar con bases de datos SQLite de una manera m√°s estructurada y segura.

- Cloudflare Workers:
  Una plataforma de servidor sin servidor que permite ejecutar c√≥digo en la red de distribuci√≥n de contenido (CDN) de Cloudflare, lo que permite respuestas m√°s r√°pidas y menor latencia al ejecutar c√≥digo cerca del usuario final‚Äã1‚Äã.
